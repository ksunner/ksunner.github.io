<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Tesseract</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a202c; /* Dark background */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen text-gray-100 p-4">
    <div id="canvas-container" class="relative w-full h-full max-w-4xl mx-auto rounded-xl shadow-2xl overflow-hidden border-2 border-gray-700 bg-gray-800">
        <canvas id="tesseract-canvas"></canvas>
        <!-- Overlay content -->
        <div class="absolute inset-0 flex flex-col items-center justify-center text-center p-8 bg-gray-900 bg-opacity-70 transition-opacity duration-500 hover:bg-opacity-0">
            <h1 class="text-5xl md:text-7xl font-bold tracking-tight mb-4 drop-shadow-lg">The Tesseract</h1>
            <p class="text-lg md:text-xl text-gray-300 max-w-prose">
                A visual representation of a hypercube, a four-dimensional analogue of a cube.
                <br class="hidden sm:inline"> Click or tap to reveal the animation.
            </p>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Scene, Camera, Renderer setup
            let scene, camera, renderer;
            let innerCube, outerCube, connectingLines;
            let canvasContainer = document.getElementById('canvas-container');
            let canvas = document.getElementById('tesseract-canvas');
            
            // Initial setup function
            function init() {
                // Create a new scene
                scene = new THREE.Scene();

                // Create a perspective camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 5;

                // Create the WebGL renderer and set its size
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Add ambient light to the scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                // Add point light for better visualization
                const pointLight = new THREE.PointLight(0xffffff, 1);
                pointLight.position.set(5, 5, 5);
                scene.add(pointLight);

                // Create the inner cube
                const innerGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const innerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8888ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                innerCube = new THREE.Mesh(innerGeometry, innerMaterial);
                scene.add(innerCube);

                // Create the outer cube
                const outerGeometry = new THREE.BoxGeometry(3, 3, 3);
                const outerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff88ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                outerCube = new THREE.Mesh(outerGeometry, outerMaterial);
                scene.add(outerCube);

                // Create the connecting lines
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xcccccc
                });

                // Get vertices of the two cubes
                const innerVertices = innerGeometry.vertices || innerGeometry.attributes.position.array;
                const outerVertices = outerGeometry.vertices || outerGeometry.attributes.position.array;

                const lineGeometry = new THREE.BufferGeometry();
                const positions = [];

                for (let i = 0; i < 8; i++) {
                    // Start point for the line (inner cube vertex)
                    positions.push(innerVertices[i * 3], innerVertices[i * 3 + 1], innerVertices[i * 3 + 2]);
                    // End point for the line (outer cube vertex)
                    positions.push(outerVertices[i * 3], outerVertices[i * 3 + 1], outerVertices[i * 3 + 2]);
                }
                
                lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                connectingLines = new THREE.LineSegments(lineGeometry, lineMaterial);
                scene.add(connectingLines);

                // Start the animation loop
                animate();
            }
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Rotate the cubes and lines
                const rotationSpeed = 0.005;
                innerCube.rotation.x += rotationSpeed;
                innerCube.rotation.y += rotationSpeed;
                outerCube.rotation.x += rotationSpeed;
                outerCube.rotation.y += rotationSpeed;
                connectingLines.rotation.x += rotationSpeed;
                connectingLines.rotation.y += rotationSpeed;

                // Render the scene
                renderer.render(scene, camera);
            }

            // Handle window resizing
            function onWindowResize() {
                // Update camera aspect ratio
                camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera.updateProjectionMatrix();
                
                // Update renderer size
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            }
            
            // Attach resize listener
            window.addEventListener('resize', onWindowResize);

            // Start everything
            init();
        };
    </script>
</body>
</html>
